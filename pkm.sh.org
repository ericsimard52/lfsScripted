#+STARTUP: hideblocks
* Todo's [7/14]
** DONE Check if partition is already mounted.
** DONE If partition are mounted, ensure they match config
   - Note taken on [2019-01-15 Tue 15:01] \\
     This is irrelevent.
     I check if /dev/xxx is mounted to specified mount point.
     if it is not it will be.
     Even if another partition is already mounted, my mount will take priority.
** DONE Check if swap is already active before activating it
** DONE what happens if md5 fails? No validation done.

** DONE Remove implementation function and variable
** TODO Provide error check and return value in all functions
** TODO call quiPkm instead of exit, this will ensure proper quit.
** DONE Adjust calls to log function, provide only 1 t to display to stdout
** DONE Slim down startup output.
** TODO [[updatePkgFromLocal]] provide error validation and return value
** TODO [[updatePkm]] Provide error validation and return value
** TODO [[startLog]] Provide validation and return value
** TODO Deactivate swap to test mountLfs swap activation
** TODO Check what happens when md5sum list cannot be retreived.
* Src Block
** pkm.sh
#+NAME: Declare
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  #!/bin/bash

  declare DEVBASE=`pwd`
  declare CONFIGFILE="$DEVBASE/etc/pkm.conf"
  declare LOGPATH="/var/log/pkm"
  declare SD SDN SDNCONF PKG EXT HASBUILDDIR BUILDDIR CONFBASE WGETURL LFS LFSUSERHOME
  declare -a PARTITIONDEV PARTITIONNAME PARTITIONMOUNT PARTITIONFS
  declare UNPACKCMD
  declare MAKEFLAGS
  declare DEBUG=0
  ## Location and file descriptor of main & secondary log destination.
  declare LOGFILE LOGFD
  declare SLP="/var/log/pkm"
  declare SECONDARYLOGPATH SECONDARYLOGFILE SECONDARYLOGFD 
  declare SECONDARYLOGACTIVE=1

  # Config files
  declare GENCONFIGFILE DEPCHECKCMDFILE PRECONFIGCMDFILE CONFIGCMDFILE COMPILECMDFILE CHECKCMDFILE
  declare PREINSTALLCMDFILE INSTALLCMDFILE
  declare -a CMDFILELIST AUTOINSTALLCMDLIST
#+END_SRC

#+NAME: Singleton
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function singleton {
      [ ! -d /var/run/pkm ] && sudo install -vdm 777 /var/run/pkm
      if [ -f /var/run/pkm/pkm.lock ]; then
          echo "Pkm is already running or has not quit properly, in that case, remove /var/run/pkm/pkm.lock" t
          return 1
      fi
      touch /var/run/pkm/pkm.lock
      [ $? -gt 0 ] && echo "Unable to create lock file. Ensure only 1 instance is running."

      # If we are lfs user, we assume installation is done and proceed as normal.
      declare usr=`whoami`
      if [[ $usr == "lfs" ]]; then
          echo "We are lfs, we assume this is a normal startup."
          return 0
      fi

      ## We are not lfs user, but if it exists, warn to run as lfs
      grep -q lfs < /etc/passwd
      if [[ $? == 0 ]] && [ $USER != "lfs" ]; then
          unset usr
          quitPkm 1 "Run this program as lfs user."
      fi
      unset usr

      ## We are not lfs user and it does not exists, install lfsScripted.
      readConfig
      startLog
      checkLfsUser
      [ $? -gt 0 ] && quitPkm 1 "Error with checkLfsUser"
      log "GEN|INFO|Installing lfsScripted into lfs home folder." t
      processCmd "sudo cp -fr $DEVBASE $LFSUSERHOME"
      [ $? -gt 0 ] && quitPkm 1 "Error copy $DEVBASE -> $LFSUSERHOME"

      checkPerm $LFSUSERHOME/lfsScripted
      [ $? -gt 0 ] && quitPkm 1 "Error in checkPerm $LFSUSERHOME/lfsScripted"
      echo "Su to lfs user, check pkm.conf and variable DEVBASE in pkm.sh"
      echo "Then su - lfs && cd lfsScripted && ./pkm.sh."
      quitPkm 0
  }
#+END_SRC

#+NAME: updatePkgFromLocal
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  ## Copy all source script folders in etc into lfs installation.
  ## This command is only usefull when in development.
  function updatePkgFromLocal {
      readConfig
      startLog
      log "GEN|INFO|Making backup of pkm.conf in $LFSUSERHOME" t
      processCmd "sudo cp -fv $LFSUSERHOME/lfsScripted/etc/pkm.conf $LFSUSERHOME/lfsScripted/etc/pkm.conf.bak"

      log "GEN|INFO|Copy source scripts to $LFSUSERHOME" t
      processCmd "sudo cp -frv ./etc/* $LFSUSERHOME/lfsScripted/etc/"

      log "GEN|INFO|Restaure pkm.conf it got overwriten." t
      processCmd "sudo mv -v $LFSUSERHOME/lfsScripted/etc/pkm.conf.bak $LFSUSERHOME/lfsScripted/etc/pkm.conf"

      checkPerm $LFSUSERHOME/lfsScripted
      [ $? -gt 0 ] && quitPkm 1 "Error with checkPerm in updatePkgFromLocal"
      checkPerm $LFSUSERHOME/lfsScripted/etc
      [ $? -gt 0 ] && quitPkm 1 "Error with checkPerm in updatePkgFromLocal"
      return 0
  }
#+END_SRC

#+NAME: updatePkm
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  ## Similar to uploadPkgFromLocal this function is called from the CLI arg passed to pkm.sh
  ## Used in development to update lfs version of pkm.sh
  function updatePkm {
      readConfig
      startLog
      log "GEN|INFO|Installing pkm.sh into lfs home." t
      processCmd "sudo cp -vf ./pkm.sh $LFSUSERHOME/lfsScripted"
      [ $? -gt 0 ] && quitPkm 1 "Error with cp pkm.sh to lfs"
      sudo sed -i -e 's:Git/::g' $LFSUSERHOME/lfsScripted/pkm.sh
      sudo sed -i -e 's:tech:lfs:g' $LFSUSERHOME/lfsScripted/etc/pkm.conf
      checkPerm $LFSUSERHOME/lfsScripted/pkm.sh
      [ $? -gt 0 ] && quitPkm 1 "Error with checkPerm in updatePkm."
      quitPkm 0
  }
#+END_SRC

#+NAME: startLog
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function startLog {
      [ ! -d $LOGPATH ] && sudo install -vdm 777 $LOGPATH
      if [ ! -f $LOGPATH/$LOGFILE ]; then
          log "NULL|INFO|Creating $LOGFILE" t
          touch $LOGPATH/$LOGFILE
          chmod 666 -v $LOGPATH/$LOGFILE
      fi
      log "NULL|INFO|Creating file descriptor for logs" t
      exec {LOGFD}>$LOGPATH/$LOGFILE
  }
#+END_SRC

#+NAME: readConfig
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  ###
  # Read config file stored in $CONFIGFILE
  ###
  function readConfig {
      log "NULL|INFO|Reading configuration file." t
      if [ ! -f $CONFIGFILE ]; then
          log "NULL|ERROR|Configuration file: $configfile is missing." t
          quitPkm 1
      fi
      while read -r line; do
          IFS=':' read -ra PARAM <<< "$line"
          case "${PARAM[0]}" in
              debug)
                  DEBUG=${PARAM[1]}
                  log "NULL|INFO|Set param DEBUG:$DEBUG" t
                  ;;
              sd)
                  SD=${PARAM[1]}
                  log "NULL|INFO|Set param sd:$SD" t
                  ;;
              confBase)
                  CONFBASE=${PARAM[1]}
                  log "NULL|INFO|Set param confBase:$CONFBASE" t
                  ;;
              MAKEFLAGS)
                  MAKEFLAGS=${PARAM[1]}
                  log "NULL|INFO|Set param MAKEFLAGS:$MAKEFLAGS" t
                  ;;
              bypassImplement)
                  BYPASSIMPLEMENT=${PARAM[1]}
                  log "NULL|INFO|Set param bypassImplement:$bypassImplement" t
                  ;;
              logFile)
                  LOGFILE=${PARAM[1]}
                  log "NULL|INFO|Set param genLogFile:$LOGFILE" t
                  ;;
              partitionDev)
                  PARTITIONDEV=(${PARAM[1]})
                  log "NULL|INFO|Set param partitionDev:$PARTITIONDEV" t
                  ;;
              partitionName)
                  PARTITIONNAME=(${PARAM[1]})
                  log "NULL|INFO|Set param partitionName:$PARTITIONNAME" t
                  ;;
              partitionMount)
                  PARTITIONMOUNT=(${PARAM[1]})
                  log "NULL|INFO|Set param partitionMount:$PARTITIONMOUNT" t
                  ;;
              partitionFs)
                  PARTITIONFS=(${PARAM[1]})
                  log "NULL|INFO|Set param partitionFs:$PARTITIONFS" t
                  ;;
              LFS)
                  LFS=${PARAM[1]}
                  log "NULL|INFO|Set param LFS:$LFS" t
                  ;;
              lfsUserHome)
                  LFSUSERHOME=${PARAM[1]}
                  log "NULL|INFO|Set param lfsUserHome:$LFSUSERHOME" t
                  ;;
              "#") continue;;
              ,*) continue;;
          esac
          unset IFS
      done < $CONFIGFILE
      export MAKEFLAGS
      log "NULL|INFO|Done reading config file." t
  }
#+END_SRC

#+NAME: mountLfs
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function mountLfs {
      log "GEN|INFO|Checking mountpoint." t
      if [ ! -d $LFS ]; then
          log "GEN|ERROR|Mount point $LFS does not exist. Creating." t
          processCmd "sudo mkdir -pv $LFS"
          [ $? -gt 0 ] && quitPkm 1 "GEN|FATAL|Error creating $LFS."
      fi
      log "GEN|INFO|Mounting partitions." t
      x=0
      pl=${#PARTITIONNAME[@]}
      log "GEN|INFO|Got $pl partition to mount." t
      while [ $x -lt $pl ]; do
          pn=${PARTITIONNAME[$x]}
          pm=${PARTITIONMOUNT[$x]}
          pd=${PARTITIONDEV[$x]}
          pf=${PARTITIONFS[$x]}

          if [[ "$pn" = "swap" ]]; then
              if [[ `grep /dev/ < <(sudo swapon -s) |wc -l` < 1 ]]; then
                  log "GEN|INFO|Found swap partition, Ativating." t
                  processCmd "sudo /sbin/swapon -v $pd"
                  [ $? -gt 0 ] && quitPkm 1 "Error activating swap"
                  log "GEN|WARNING|Swap should be last to mount, if not, next partition will not be mounted." t
                  return 0
              else
                  log "GEN|INFO|Swap already active, skipping." t
                  return 0
              fi
          fi

          if [ ! -d $LFS$pm ]; then
              log "GEN|WARNING|$LFS$pm does not exists, creating." t
              processCmd "sudo mkdir -pv $LFS$pm"
              [ $? -gt 0 ] && quitPkm 1 "$LFS$pm does not exists and unable to create."
          fi
          log "GEN|INFO|Check if $pd mounted on $pm" t
          if [[ `grep "$pd on $pm" < <(mount) | wc -l` < 1 ]]; then
              log "GEN|INFO|Mounting $pd on $pm" t
              processCmd "sudo mount -v -t $pf $pd $LFS$pm"
              [ $? -gt 0 ] && quitPkm 1 "Unable to mount $pd on $pm"
              ((x++))
          else
              log "GEN|INFO|$pd already mounted on $pm, skipping." t
              ((x++))
          fi
      done
      return 0
  }

#+END_SRC

#+NAME: unMountLfs
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function unMountLfs {
      log "GEN|INFO|UnMounting partitions." t
      x=0
      pl=${#PARTITIONNAME[@]}
      log "GEN|INFO|Got $pl partition to unmount." t
      while [ $x -lt $pl ]; do
          pn=${PARTITIONNAME[$x]}
          pm=${PARTITIONMOUNT[$x]}
          pd=${PARTITIONDEV[$x]}
          pf=${PARTITIONFS[$x]}

          if [[ "$pn" = "swap" ]]; then
              log "GEN|WARN|Not turning off swap, there is a host system active." t
              break
          fi

          log "GEN|INFO|Check if $pd mounted on $pm" t
          if [[ `grep "$pd on $pm" < <(mount) | wc -l` > 0 ]]; then
              log "GEN|INFO|Unmounting $pd from $pm" t
              processCmd "sudo umount -v $pd"
              [ $? -gt 0 ] && log "{GEN,ERR}|ERROR|Error unmounting $pd, check manually." t
          else
              log "GEN|INFO|$pd not mounted." t
          fi
          ((x++))
      done
      return 0
  }

#+END_SRC

#+NAME: checkSources
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function checkSources {
      log "GEN|INFO|Checking if source directory $SD exists." t
      if [ ! -d $SD ]; then
          log "GEN|WARNING|Source directory $SD does not exists, creating." t
          processCmd "sudo mkdir -vp $SD"
          [ $? -gt 0 ] && quitPkm 1 "Unable to create $SD"
          processCmd "sudo chmod -v a+wt $SD"
          [ $? -gt 0 ] && log "GEN|WARNING|chmod a+wt on $SD reported failure, check manually." t
      fi
      log "GEN|INFO|Done." t

      log "GEN|INFO|Do we have wget.list?" t
      if [ ! -f $CONFBASE/wget.list ]; then
          log "GEN|WARNING|wget.list not found, fetching." t
          processCmd "sudo wget -v -O $CONFBASE/wget.list -v \"http://www.linuxfromscratch.org/lfs/view/stable/wget-list\""
          [ $? -gt 0 ] && quitPkm 1 "Unable to fetch wget.list. I will crash if I don't quit now"
      fi
      log "GEN|INFO|Checking source packages." t
      for line in `cat $CONFBASE/wget.list`; do
          fn=$(basename $line)
          log "GEN|INFO|Checking for $fn" t
          if [ ! -f $SD/$fn ]; then
              log "GEN|INFO|$fn not found, fetching." t
              processCmd "sudo wget -v $line -O $SD/$fn"
              if [ $? -gt 0 ]; then
                  log "GEN|ERROR|Unable to fetch $fn." t
                  [ -e $SD/$fn ] && processCmd "rm -v $SD/$fn"
              fi
            
          fi
      done

      log "GEN|INFO|Do we have md5sums?" t
      if [ ! -f $CONFBASE/md5sums ]; then
          log "GEN|WARNING|md5sums not found, fetching." t
          processCmd "sudo wget -v -O $CONFBASE/md5sums -v \"http://www.linuxfromscratch.org/lfs/view/stable/md5sums\""
          [ $? -gt 0 ] && log "GEN|WARNING|Unable to fetch md5sums check list. Unsure how the program will behave at check time." t
      fi

      # Touch dummy pkg
      declare -a _dummyPkgList=('dummy.tar.xz')
      declare _dp
      for _dp in ${_dummyPkgList[@]}; do
          if [ ! -e $SD/$_dp ]; then
              log "GEN|INFO|Creating dummy package $_dp" t
              processCmd "sudo touch $SD/$_dp"
              [ $? -gt 0 ] && log "GEN|WARNING|Unable to create $_dp dummy pkg. Also, make this better. Dummy Package will be needed more often." t
          fi
      done
      unset _dummyPkgList _dp
      log "GEN|INFO|Checking md5." t
      mPush $SD
      processCmd "sudo md5sum -c $CONFBASE/md5sums"
      [ $? -gt 0 ] && mPop && quitPkm 1 "Source md5sum check failed. Check logs for details."
      mPop
      return 0
  }

#+END_SRC

#+NAME: checkLfsUser
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function checkLfsUser {
      log "GEN|INFO|Checking LFS group & user." t
      grep -q lfs < /etc/group
      if [[ $? > 0 ]]; then
          log "GEN|WARNING|lfs group does not exists, creating." t
          processCmd "sudo groupadd lfs"
          [ $? -gt 0 ] && quitPkm 1 "Unable to create lfs group"
      fi

      grep -q lfs < /etc/passwd
      if [[ $? > 0 ]];then
          log "GEN|WARNING|lfs user not found. Fixing." t
          processCmd "sudo useradd -s /bin/bash -g lfs -d $LFSUSERHOME -m -k $DEVBASE/etc/lfsHomeSkel lfs"
          [ $? -gt 0 ] && quitPkm 1 "Unable to add lfs user."

          log "GEN|INFO|Set password for lfs user." t
          sudo passwd lfs
          [ $? -gt 0 ] && quitPkm 1 "Error setting lfs password"
      fi
      return 0

  }

#+END_SRC

#+NAME: checkStruct
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function checkStruct {
      log "GEN|INFO|Checking $LFS/tools." t
      if [ ! -d $LFS/tools ]; then
          log "GEN|WARNING|$LFS/tools does not exists, creating." t
          processCmd "sudo mkdir -pv $LFS/tools"
          [ $? -gt 0 ] && quitPkm 1 "Error create $LFS/tools."
      fi
      if [ ! -h /tools ]; then
          log "GEN|WARNING|/tools link does not exists, creating." t
          processCmd "sudo ln -sv $LFS/tools /"
          [ $? -gt 0 ] && quitPkm 1 "Error creating /tools link."
      fi
      return 0
  }

#+END_SRC

#+NAME: checkPerm
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function checkPerm {
      log "GEN|INFO|Checking permission and ownership" t
      declare -a toCheck
      declare res=0
      if [ $1 ]; then
          toCheck=($1)
      else
          toCheck=($LFS/tools $SD $DEVBASE/etc $DEVBASE/var $LFSUSERHOME)
      fi
      for d in ${toCheck[@]}; do
          log "GEN|INFO|Check permissions and owners of $d" t
          if [ -d $d ]; then
              for file in $d; do
                  user=`stat -c %U $file`
                  log "GEN|INFO|Owner of $file: $user"
                  if [[ ! "$user" = "lfs" ]]; then
                      log "GEN|INFO|Fixing ownership of $file." t
                      processCmd "sudo chown -vR lfs:lfs $file"
                      [ $? -gt 0 ] && log "GEN|ERROR|Error changing ownership of $file" t && res=1
                      processCmd "sudo chmod g+w -vR $file"
                      [ $? -gt 0 ] && log "GEN|ERROR|Error changing mode of $file" t && res=1
                  fi

              done
          elif [ -f $d ]; then
              user=`stat -c %U $d`
              log "GEN|INFO|Owner of $file: $user"
              if [[ ! "$user" = "lfs" ]]; then
                  log "GEN|INFO|Fixing ownership of $file." t
                  processCmd "sudo chown -v lfs:lfs $file"
                  [ $? -gt 0 ] && log "GEN|ERROR|Error changing ownership of $file" t && res=1
                  processCmd "sudo chmod g+w -v $file"
                  [ $? -gt 0 ] && log "GEN|ERROR|Error changing mode of $file" t && res=1
              fi
          fi
      done
      return $res
  }
#+END_SRC

#+NAME: startupCheck
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function startupCheck {
      log "GEN|INFO|Checking environment." t
      checkLfsUser
      [ $? -gt 0 ] && quitPkm 1 "Error with checkLfsUser"
      mountLfs
      [ $? -gt 0 ] && quitPkm 1 "Error with mountLfs"
      checkSources
      [ $? -gt 0 ] && log "GEN|ERROR|Error with checkSources, make sure all is good." t
      checkStruct
      [ $? -gt 0 ] && quitPkm 1 "Error with checkStruct, to risky to continue."
      checkPerm
      [ $? -gt 0 ] && quitPkm 1 "Errpr with checkPerm, to risky to continue."
      return 0
  }

#+END_SRC

#+NAME: checkInstalled
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function checkInstalled {
      processCmd "command -v "$1
      [ $? -gt 0 ] && return 1 || return 0
  }
#+END_SRC

#+NAME: checkLibInstalled
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function checkLibInstalled {
      processCmd "sudo ldconfig -p | grep $1"
      [ $? -gt 0 ] && return 1 || return 0
  }
#+END_SRC

#+NAME: getVersion
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function getVersion {
      reqCmd="$1"
      log "GEN|INFO|Getting version of "$reqCmd t
      cmdVersion=`timeout 5 $1 --version 2>&1  | sed '/^$/d' |head -n1 | egrep -o "([0-9]{1,}\.)+[0-9]{1,}"`
      if [[ $? > 0 ]]; then
          log "PKG|WARNING|Unable to fetch version, attempting another way." t
          cmdVersion=`$1 -version 2>&1  | sed '/^$/d' |head -n1 | egrep -o "([0-9]{1,}\.)+[0-9]{1,}"`
          if [[ $? > 0 ]]; then
              log "PKG|ERROR|Could not find version for $1." t
              return 1
          fi
      fi
      log "PKG|INFO|Found version: $cmdVersion." t
      log "GEN|INFO|Removing all non numeric character." t
      cmdVersion=$(echo $cmdVersion | sed 's/[^0-9]*//g')
      log "GEN|INFO|cmdVersion: $cmdVersion." t
      eval "$2=$cmdVersion"
      [ $? -gt 0 ] && return 1 || return 0
  }
#+END_SRC

#+NAME: verComp
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function vercomp {
      declare cp='>='; ## Default comparator if not provided
      if [[ $3 ]]; then
          cp=$3
      fi
      log  "GEN|INFO|Comparing version: $1 $cp $2" t
      if [[ $1 == $2 ]]; then
          return 0
      fi
      local IFS=.
      local i installedVer=($1) neededVer=($2) iv nv
      ivCount=0
      nvCount=0
      nvPad=0
      ivPad=0
      for (( i=0; i<${#installedVer[@]}; i++ )); do
          iv=$iv${installedVer[$i]}
      done

      for (( i=0; i<${#neededVer[@]}; i++ )); do
          nv=$nv${neededVer[$i]}
      done
      iv=$(echo $iv | sed 's/[^0-9]*//g')
      nv=$(echo $nv | sed 's/[^0-9]*//g')
      log "GEN|INFO|Getting count for iv: $iv" - t
      ivCount=${#iv}
      log "GEN|INFO|Getting count for mv: $nv" - t
      nvCount=${#nv}
      log "GEN|INFO|nv: $nv" - t
      log "GEN|INFO|iv: $iv" - t
      log "GEN|INFO|ivCount: $ivCount" - t
      log "GEN|INFO|nvCount: $nvCount" - t
      if [ $ivCount -lt $nvCount ]; then
          ivPad=$(( $nvCount - $ivCount ))
          log "GEN|INFO|ivPad: $ivPad" - t
      elif [ $nvCount -lt $ivCount ]; then
          nvPad=$(( $ivCount - $nvCount ))
          log "GEN|INFO|nvPad: $nvPad" - t
      else
          log "GEN|INFO|No padding needed" - t
      fi
      for (( i=0; i<$nvPad; i++ )); do
          nv=$nv"0"
      done
      for (( i=0; i<$ivPad; i++ )); do
          iv=$iv"0"
      done

      log "GEN|INFO|iv: $iv nv: $nv" - t
      unset ivCount nvCount nvPad ivPad i
      case "$cp" in
          ">")
              [ $iv -gt $nv ] && return 0 || return 1
              ;;
          "<")
              [ $iv -lt $nv ] && return 0 || return 1
              ;;
          "="|"==")
              [ $iv -eq $nv ] && return 0 || return 1
              ;;
          ">=")
              if (( $iv >= $nv )); then
                  return 0
              fi
              ;;
          "<=")
              if (( $iv <= $nv )); then
                  return 0
              fi
              ;;
          ,*)
              log "{GEN,ERR}|ERROR|Unknown comparator in checkVersion." t
              return 1
              ;;
      esac

      return 1
  }

#+END_SRC

#+NAME: dumpEnv
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function dumpEnv {
  printf "\e[1mEnvironment Var:\e[0m
  \e[34mDEBUG: \e[32m$DEBUG
  \e[34msd: \e[32m$SD
  \e[34msdn: \e[32m$SDN
  \e[34mtf: \e[32m$TF
  \e[34mSDNCONF: \e[32m$SDNCONF
  \e[34mext: \e[32m$EXT
  \e[34mhasBuildDir: \e[32m$HASBUILDDIR
  \e[34mMAKEFLAGS: \e[32m$MAKEFLAGS
  \e[34mbuildDir: \e[32m$BUILDDIR
  \e[34mLFS: \e[32m$LFS
  \e[34mconfigFile: \e[32m$CONFIGFILE
  \e[34mconfBase: \e[32m$CONFBASE
  \e[34mgenLog: \e[32m$GENLOGFILE
  \e[34mgenLogFD: \e[32m$GENLOGFD
  \e[34mpkgLog: \e[32m$PKGLOGFILE
  \e[34mpkgLogFD: \e[32m$PKGLOGFD
  \e[34mimpLog: \e[32m$IMPLOGFILE
  \e[34mimpLogFD: \e[32m$IMPLOGFD
  \e[34merrLog: \e[32m$ERRLOGFILE
  \e[34merrLogFD: \e[32m$ERRLOGFD
  \e[34mNEXTPKG: \e[32m$NEXTPKG
  \e[0m\n"
  }
#+END_SRC

#+NAME: log
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function log {
      ## Format
      ## log "LEVEL|..." PRINTOSTDOUT DEBUGONLYMESSAGE
      ## log "INFO|..." t = print to stdout
      ## log "INFO|..." t t = print to stdout only if debug=1
      ## log "INFO|..." - t = process only if debug=1 and send only to LOGFILE
      ## Messages are always sent to LOGFILE

      if [ $3 ] && [[ $DEBUG = 0 ]]; then # if 3 param set, we process msg only if debug is 1
          return
      fi
      declare _LEVEL _COLOR _MSG _M _LOGMSG _CALLER _CALLERLOG

      MSGEND=" \e[0m" ## Clear all formatting

      ## Setting up file descriptor destination
      IFS='|' read -ra PARTS <<< $1
      ### Set color formatting
      case "${PARTS[1]}" in
          INFO)
              _LEVEL=INFO
              _COLOR="\e[39m"
              ;;
          WARNING)
              _LEVEL=WARNING
              _COLOR="\e[33m"
              ;;
          ERROR)
              _LEVEL=ERROR
              _COLOR="\e[31m"
              ;;
          FATAL)
              _LEVEL=FATAL
              _COLOR="\e[31m"
              ;;
      esac

      ### Append message provided by caller
      _M="${PARTS[2]}"
      if [[ "$_M" = "" ]]; then
          return
      fi

      if [ $SDN ]; then
          _CALLER="\e[32m"$PKG"\e[0m "
          _CALLERLOG=$PKG
      else
          _CALLERLOG="NONE"
          _CALLER="\e[32mNONE\e[0m "
      fi
      _MSG=$_COLOR$_LEVEL" - "$_CALLER":"$_COLOR$_M$_MSGEND ## Full message string
      _LOGMSG=$_LEVEL" - "$_CALLERLOG":"$_M$_MSGEND

      # Printo stdOut
      if [ $SECONDARYLOGACTIVE -eq 0 ]; then
          [ ${SECONDARYLOGFD} ] && echo $_LOGMSG >&${SECONDARYLOGFD}
      else
          [ ${LOGFD} ] && echo $_LOGMSG >&${LOGFD}
      fi
      if [[ $2 ]] && [[ "$2" = "t" ]]; then # if t after message, print to stdout
          echo -e $_MSG
      fi


      unset IFS _FDs _LEVEL _COLOR _MSG _M _MSGEND _LOGMSG _CALLER _CALLERLOG
      return
  }
#+END_SRC

#+NAME: loadPkg
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function loadPkg {
      if [[ $PKG ]]; then
          log "GEN|INFO|Unloading $PKG from memory." t
          unloadPkg
      fi

      if [ $1 ]; then
          PKG=$1
      else
          promptUser "Which package?"
          read PKG
      fi
      if [[ "$PKG" == "" ]]; then
          log "ERR|INFO|Empty package provided..."
          return 1
      fi
      if [ ! -d $CONFBASE/$PKG ]; then
          declare -a foundFiles
          for file in `find $CONFBASE -maxdepth 1 -type d -iname "$PKG*"`; do
              promptUser "FoundFiles: $file\n Use it? Y/n"
              read u
              case $u in
                  [nN])
                      continue
                      ;;
                  [yY]|*)
                      log "GEN|INFO|Using: $file" t
                      PKG=$(basename $file)
                      if [ ! -d $CONFBASE/$PKG ]; then
                          log "ERR|FATAL|Could not find $PKG after finding it????" t
                          return 1
                      fi
                      break
                      ;;
              esac
          done
          if [ ! -d $CONFBASE/$PKG ]; then
              log "ERR|FATAL|No package found for $PKG." t
              return 1
          fi
      fi
      SDNCONF=$CONFBASE/$PKG
      log "PKG|INFO|SDNCONF set: $SDNCONF." t
      GENCONFIGFILE="$SDNCONF/$PKG.conf"
      log "PKG|INFO|genConfigFile set: $GENCONFIGFILE." t
      if [ ! -f $GENCONFIGFILE ]; then
          log "ERR|ERROR|Package general config file missing" t
          return 1
      fi

      log "PKG|INFO|Reading config file into variables" t
      while read -r line; do
          IFS=':' read -ra PARAM <<< "$line"
          case "${PARAM[0]}" in
              tf)
                  log "PKG|INFO|tf: ${PARAM[1]}" t
                  TF=${PARAM[1]}
                  ;;
              sdn)
                  log "PKG|INFO|sdn: ${PARAM[1]}" t
                  SDN=${PARAM[1]}
                  ;;
              sd)
                  log "PKG|INFO|sd: ${PARAM[1]}" t
                  SD=${PARAM[1]}
                  ;;
              hasBuildDir)
                  log "PKG|INFO|hasBuildDir: ${PARAM[1]}" t
                  HASBUILDDIR=${PARAM[1]}
                  ;;
              bypassImplement)
                  log "PKG|INFO|bypassImplement: ${PARAM[1]}" t
                  BYPASSIMPLEMENT=${PARAM[1]}
                  ;;
              tasks)
                  log "PKG|INFO|Loading tasks list." t
                  IFS=',' read -ra TASK <<< "${PARAM[1]}"
                  x=0
                  while [[ $x < ${#TASK[@]} ]]; do
                      log "PKG|INFO|Adding ${TASK[$x]}." t
                      AUTOINSTALLCMDLIST+=(${TASK[$x]})
                      ((x++))
                  done
                  IFS=':'
                  ;;
              makeflags)
                  log "PKG|INFO|Chaning makeflags" t
                  MAKEFLAGS=${PARAM[1]}
                  ;;
              debug) DEBUG=${PARAM[1]};;
              nextPkg) NEXTPKG=${PARAM[1]};;
              ,*) log "{GEN,ERR}|ERROR|Unknow params: ${PARAMS[1]}" t;;
          esac
          unset IFS
      done < $GENCONFIGFILE


      log "GEN|INFO|Check if source package exists: $SD/$tf" t
      # Check if source package exists
      ## What is this
      if [ ! -f $SD/$TF ]; then
          log "PKG|WARNING|Why are we doing this?" t
          log "{GEN,ERR}|WARNING|Package $tf not found in source $SD, creating." t
          processCmd " install -vm664 $DEVBASE/sources/$TF $SD/$TF"
          return
      fi

      EXT="${TF##*.}"
      log "PKG|INFO|Extension established: $EXT" t
      log "PKG|INFO|Calling setCmdFileList." t
      setCmdFileList
      if [ $HASBUILDDIR -lt 1 ]; then
          BUILDDIR=$SD/$SDN/build
          log "GEN|INFO|Checking if build dir: $BUILDDIR exists." t
          if [ ! -d "$BUILDIR" ]; then
              log "GEN|WARNING|Build directory flag set, but dir does not exist, creating..." t
              processCmd "install -vdm755 $BUILDDIR"
              [ $? -gt 0 ] && log "{PKG,ERR}|ERROR|Error creating $BUILDDIR." t && return 1
          fi
      else
          BUILDDIR=$SD/$SDN
      fi
      log "PKG|INFO|buildDir set: $BUILDDIR." t

      # Secondary log setup
      SECONDARYLOGPATH=$SLP/$SDN
      [ ! -d $SECONDARYLOGPATH ] && processCmd "install -vdm 777 $SECONDARYLOGPATH"
      # Adjusting the unpack commands
      log "GEN|INFO|Adjusting unpack command for $EXT." t
      if [[ "$EXT" == "xz" ]]; then
          UNPACKCMD="tar xvf $TF"
      elif [[ "$EXT" == "gz" ]]; then
          UNPACKCMD="tar xvfz $TF"
      elif [[ "$EXT" == "gzip" ]]; then
          UNPACKCMD="tar xvfz $TF"
      elif [[ "$EXT" == "bz2" ]]; then
          UNPACKCMD="tar xvfj $TF"
      elif [[ "$EXT" == "tgz" ]]; then
          UNPACKCMD="tar xvfz $TF"
      else
          log "ERR|FATAL|Unknown package unpack method." true
          return 0
      fi
      log "PKG|INFO|unpackCmd set: $UNPACKCMD." t
      return 0
  }

#+END_SRC

#+NAME: unloadPkg
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function unloadPkg {
      unset -v PKG SDNCONF TF SDN HASBUILDDIR BUILDDIR LD EXT UNPACKCMD BANNER GENCONFIGFILE DEPCHECKCMDFILE PRECONFIGCMDFILE CONFIGCMDFILE COMPILECMDFILE CHECKCMDFILE PREINSTALLCMDFILE INSTALLCMDFILE PREIMPLEMENTCMDFILE POSTIMPLEMENTCMDFILE CMDFILELIST PRECONFIGCMD CONFIGCMD COMPILECMD CHECKCMD PREINSTALLCMD INSTALLCMD PREIMPLEMENTCMD POSTIMPLEMENTCMD AUTOINSTALLCMDLIST NEXTPKG
      SECONDARYLOGPATH=$SLP
      SECONDARYLOGACTIVE=1
      isImplemented=1
      
  }
#+END_SRC

#+NAME: unpack
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function unpack {
      log "{GEN,PKG}|INFO|Unpacking source code $TF" t

      if [ ! -f $SD/$TF ]; then
          log "{GEN,PKG,ERR}|FATAL|$TF not found." t
          return 1
      fi

      log "PKG|INFO|Running Cmd: $UNPACKCMD" t t
      mPush $SD
      processCmd "${UNPACKCMD}"
      [ $? -gt 0 ] && log "{PKG,ERR}|ERROR|Error unpacking with $UNPACKCMD" t && return 1
      if [ $HASBUILDDIR == 0 ] && [ ! -d $SD/$SDN/build ]; then
          log "PKG|INFO|Creating build directory" t
          processCmd "install -olfs -glfs -vdm755 $SD/$SDN/build"
          [ $? -gt 0 ] && log "{PKG,ERR}|ERROR|Error creating build directory" t && return 1
      fi

      log "{GEN,PKG}|INFO|Done." t
      mPop
      return 0
  }
#+END_SRC

#+NAME: autoInstall
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function autoInstall {
      log "GEN|INFO|AutoInstall will be running the following tasks:"
      i=0
      while [[ $i < ${#AUTOINSTALLCMDLIST[@]} ]]; do
          echo "${AUTOINSTALLCMDLIST[$i]}"
          ((i++))
      done
      promptUser "Do you wanto start now?"
      read y
      case $y in
          [nN])
              return 0
              ;;
          [yY]|*)
              runAutoInstall
              [ $? -gt 0 ] && log "{GEN,ERR}|ERROR|Error during autoInstall." t && return 1
              ;;
      esac
      return 0
  }

#+END_SRC

#+NAME: runAutoInstall
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function runAutoInstall {
      ii=0
      log "PKG|INFO|Starting auto install." t
      while [[ $ii < ${#AUTOINSTALLCMDLIST[@]} ]]; do
          f=${AUTOINSTALLCMDLIST[$ii]}
          ((ii++))
          log "GEN|INFO|Sourcing $f." true
          evalPrompt $f
          [ $? -gt 0 ] && log "{PKG,ERR}|ERROR|Error sourcing $f. Aborting!" t && return 1
      done
      log "PKG|INFO|Auto install completed, all seems to be good." t
      return 0
  }

#+END_SRC

#+NAME: searchPkg
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function searchPkg {
      # If we can't file the package (source tar), we do a search for the term provided by the user.
      declare -a foundFiles
      for file in `find $SD -maxdepth 1 -type f -iname "$1*"`; do
          promptUser "FoundFiles: $file\n Use it? Y/n"
          read u
          case $u in
              [nN])
                  continue
                  ;;
              [yY]|*)
                  log "GEN|INFO|Using: $file" t
                  PKG=$(basename $file)
                  log "{GEN,PKG}|INFO|pkg seto $PKG" t
                  if [ ! -f $SD/$PKG ]; then
                      log "{GEN,ERR}|FATAL|Could not find $PKG after finding it????" t
                      return 1
                  fi
                  break
                  ;;
          esac
      done
      if [ ! -f $SD/$PKG ]; then
          log "GEN|WARNING|No package found for $PKG*." t
          return 1
      fi
  }

#+END_SRC

#+NAME: processCmd
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function processCmd {
      eval "tput sgr0"
      log "GEN|INFO|Processing cmd: $@"
      if [[ $DEBUG = 0 ]]; then
          [ $SECONDARYLOGACTIVE -eq 0 ] && $@ >&${SECONDARYLOGFD} 2>&1 || $@ >&${LOGFD} 2>&1
      elif [[ $DEBUG = 1 ]]; then
          [ $SECONDARYLOGACTIVE -eq 0 ] && $@ | tee >&${SECONDARYLOGFD} 2>&1 || $@ | tee >&${LOGFD} 2>&1
      fi
      [ $? -gt 0 ] && log "GEN|ERROR|Error processing cmd: $@" t && return 1
      return 0
  }
#+END_SRC

#+NAME: promptUser
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function promptUser {
      COLOR="\e[37m"
      echo -en $COLOR$1" : \e[0m"
  }
#+END_SRC

#+NAME: sourceScript
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function sourceScript {
      c=$1
      log "GEN|INFO|Sourcing: $c" t
      source $c
      [ $? -gt 0 ] && log "{GEN,ERR}|ERROR|Failed." t && return 1
      log "GEN|INFO|Success." t
      return 0
  }
#+END_SRC

#+NAME: cleanup
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function cleanup {
      log "GEN|INFO|Cleaning up source file $SD/$SDN" t
      processCmd "rm -vfr $SD/$SDN"
      [ $? -gt 0 ] && log "{PKG,ERR}|ERROR|Error cleaning up." t && return 1
      return 0
  }
#+END_SRC

#+NAME: quit
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function quitPkm {
      ## First log exit message if present
      if [ -n "$2" ]; then
          log "GEN|WARNING|Exist Message received: $2"
      fi
      declare ret=0 ## Default exit value
      if [ $1 ]; then ret=$1; fi ## Override exit value

      [ $? -gt 0 ] && echo "ERROR with unMountLfs, CHECK YOUR SYSTEM." && ret=1

      log "GEN|INFO|Closing logs." t
      [ ${LOGFD} ] && exec {LOGFD}>&-

      unset LOGFILE
      unset LOGFD

      if [ $SECONDARYLOGACTIVE -eq 0 ]; then
         closeSecondaryLog
      fi
      if [ -f /var/run/pkm/pkm.lock ]; then
          log "GEN|INFO|Removing pkm lock." t
          sudo rm /var/run/pkm/pkm.lock
          [ $? -gt 0 ] && echo "Error removing lock." && exit $res
      fi
      if [[ ! "$2" = "" ]]; then
          echo "Quitting message: $2."
      fi

      exit $ret
  }
#+END_SRC

#+NAME: setCmdFileList
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function setCmdFileList {
      log "GEN|INFO|Setting up command files list." true
      if [[ "$SDN" = "" ]]; then
          log "{GEN,ERR}|ERROR|SDN is not set." true
          return 1
      fi
      if [ "$SDNCONF" == "" ]; then
          log "{GEN,ERR}|ERROR|SDNCONF not set." true
          return 1
      fi

      DEPCHECKCMDFILE=$SDNCONF/depcheck
      PRECONFIGCMDFILE=$SDNCONF/preconfig
      CONFIGCMDFILE=$SDNCONF/config
      COMPILECMDFILE=$SDNCONF/compile
      CHECKCMDFILE=$SDNCONF/check
      PREINSTALLCMDFILE=$SDNCONF/preinstall
      INSTALLCMDFILE=$SDNCONF/install
      PREIMPLEMENTCMDFILE=$SDNCONF/preimplement
      POSTIMPLEMENTCMDFILE=$SDNCONF/postimplement
      CMDFILELIST=(
          $DEPCHECKCMDFILE
          $PRECONFIGCMDFILE
          $CONFIGCMDFILE
          $COMPILECMDFILE
          $CHECKCMDFILE
          $PREINSTALLCMDFILE
          $INSTALLCMDFILE
          $PREIMPLEMENTCMDFILE
          $POSTIMPLEMENTCMDFILE
      )
      return 0
  }

#+END_SRC

#+NAME: listTask
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function listTask {
      i=0
      last=${#AUTOINSTALLCMDLIST[@]}
      ((last--))

      while [[ $i < ${#AUTOINSTALLCMDLIST[@]} ]]; do
          [ $i -eq $last ] && echo -n "${AUTOINSTALLCMDLIST[$i]}" || echo -n "${AUTOINSTALLCMDLIST[$i]}, "
          ((i++))
      done
      echo ""
  }
#+END_SRC

#+NAME: mPush
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function mPush {
      [ ! $1 ] && return 1
      processCmd "pushd $1"
      [ $? -gt 0 ] && quitPkm 1 "Error pushing $1 onto stack." || return 0
  }
#+END_SRC

#+NAME: mPop
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function mPop {
      processCmd "popd"
      [ $? -gt 0 ] && quitPkm 1 "Error poping directory of the stack" || return 0
  }
#+END_SRC

#+NAME: runAutoBuildTmpToolChain
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function runAutoBuildTmpToolChain {
      bsrc=$DEVBASE/etc/autoBuildTmpToolChain/list
      [ ! -f $bsrc ] && log "{GEN,ERR}|ERROR| autoBuildTempToolChain directory not present et $DEVBASE/etc" t && return 1
      declare -a pkglist
      while read -r bline; do
          pkglist+=($bline)
      done < $bsrc
      for item in ${pkglist[@]}; do
          log "GEN|INFO|Loading $item" t
          loadPkg $item
          [ $? -gt 0 ] && log "GEN|ERR|Error load $item" t && return 1
          runAutoInstall
          [ $? -gt 0 ] && log "GEN|ERR|Error with autoinstall of $item" t && return 1
          log "GEN|INFO|Sourcing $item succesful." t
          unloadPkg
      done
      log "GEN|INFO|DONE BUIL TEMP" t
      return 0
  }
#+END_SRC

#+NAME: setupSecondaryLog
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function setupSecondaryLog {
      log "NULL|INFO|Setting up secondary log." t
      if [ ! $1 ]; then
         log "NULL|WARNING|Call to set secndary log, no parameters provided." t
         return 1
      fi
      SECONDARYLOGFILE=$1
      if [ ! -e $SECONDARYLOGPATH/$SECONDARYLOGFILE ]; then
         log "NULL|INFO|$SECONDARYLOGFILE does not exists. Creating." t
         processCmd "touch $SECONDARYLOGPATH/$SECONDARYLOGFILE"
         processCmd "chmod 666 $SECONDARYLOGPATH/$SECONDARYLOGFILE"
      fi
      exec {SECONDARYLOGFD}>$SECONDARYLOGPATH/$SECONDARYLOGFILE
      if [ $? -gt 0 ]; then
          log "NULL|ERROR|Error setting up file descriptor for $SECONDARYLOGPATH/$SECONDARYLOGFILE"
          return 1
      fi
      log "NULL|INFO|Secondary log activated. All log will go in $SECONDARYLOGPATH/$SECONDARYLOGFILE." t
      SECONDARYLOGACTIVE=0
      return 0
  }
#+END_SRC

#+NAME: closeSecondaryLog
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function closeSecondaryLog {
      log "NULL|INFO|Closing secondary log." t
      [ ${SECONDARYLOGFD} ] && exec {SECONDARYLOGFD}>&-
      if [ $? -gt 0 ]; then
          log "NULL|ERROR|Error closing file descriptor: for $SECONDARYLOGPATH/$SECONDARYLOGFILE"
          return 1
      fi
      SECONDARYLOGACTIVE=1
      SECONDARYLOGFILEPATH=$SLP
      unset SECONDARYLOGFILE
      log "NULL|INFO|Secondary log deactivated." t
      return 0
  }
#+END_SRC

#+NAME: evalPrompt
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function evalPrompt {
      case $1 in
          listcommands)
              listCommands
              ;;
          unpack)
              setupSecondaryLog "unpack.log"
              unpack
              _r=$?
              closeSecondaryLog
              return $_r
              ;;
          depcheck)
              setupSecondaryLog "depcheck.log"
              log "GEN|INFO|Running dependency check scripts" t
              sourceScript "${DEPCHECKCMDFILE}"
              _r=$?
              closeSecondaryLog
              return $_r
              ;;
          preconfig)
              setupSecondaryLog "preconfig.log"
              log "GEN|INFO|Running pre-config scripts" t
              if [ $HASBUILDDIR -lt 1 ]; then
                  mPush $SD/$SDN
              else
                  mPush $BUILDDIR
              fi
              sourceScript "${PRECONFIGCMDFILE}"
              res=$?
              mPop
              closeSecondaryLog
              return $res
              ;;
          config)
              setupSecondaryLog "config.log"
              log "GEN|INFO|Running config scripts" true
              mPush $BUILDDIR
              sourceScript "${CONFIGCMDFILE}"
              res=$?
              mPop
              closeSecondaryLog
              return $res
              ;;
          compile)
              setupSecondaryLog "compile.log"
              log "GEN|INFO|Running compile scripts" true
              mPush $BUILDDIR
              sourceScript "${COMPILECMDFILE}"
              res=$?
              mPop
              closeSecondaryLog
              return $res
              ;;
          check)
              setupSecondaryLog "check.log"
              log "GEN|INFO|Running check scripts" true
              mPush $BUILDDIR
              sourceScript "${CHECKCMDFILE}"
              res=$?
              mPop
              closeSecondaryLog
              return $res
              ;;
          preinstall)
              setupSecondaryLog "preinstall.log"
              log "GEN|INFO|Running PreInstall scripts" true
              mPush $BUILDDIR
              sourceScript "${PREINSTALLCMDFILE}"
              res=$?
              mPop
              closeSecondaryLog
              return $res
              ;;
          install)
              setupSecondaryLog "install.log"
              log "GENINFO|Running install scripts" true
              mPush $BUILDDIR
              sourceScript "${INSTALLCMDFILE}"
              res=$?
              mPop
              closeSecondaryLog
              [ $res -eq 0 ] && [ $NEXTPKG ] && log "GEN|INFO|Next package: $NEXTPKG" t
              return $res
              ;;
          preimplement)
              setupSecondaryLog "preimplement.log"
              log "GEN|INFO|Running preImplement scripts" true
              mPush $BUILDDIR
              sourceScript "${PREIMPLEMENTCMDFILE}"
              res=$?
              closeSecondaryLog
              mPop
              return $res
              ;;
          autoinstall)
              autoInstall
              ;;
          listtask)
              listTask
              ;;
          cleanup)
              setupSecondaryLog "cleanup.log"
              cleanup
              closeSecondaryLog
              ;;
          preppkg)
              prepPkg
              ;;
          loadpkg)
              loadPkg
              ;;
          unloadpkg)
              unloadPkg
              ;;
          backup)
              requestHostBackup
              ;;
          dumpenv)
              dumpEnv
              ;;
          debug)
              if [[ "$2" = "" ]]; then
                  return
              fi
              DEBUG=$2
              ;;
          reload)
              readConfig
              ;;
          quit)
              log "GEN|INFO|Quitting"
              quitPkm
              ;;
          ilsil)
              importLfsScriptedImplementLogs
              ;;
          autobuild)
              runAutoBuildTmpToolChain
              ;;
          ,*)
              log "GEN|INFO|Unknown command: $1" t
              return 1
              ;;
      esac

  }

#+END_SRC

#+NAME: prompt
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  function prompt {
      while true; do
          promptUser "Input."
          read -e command
          evalPrompt $command
          [ $? -gt 0 ] && log "{GEN,ERR}|ERROR|EvalPrompt returned error on $command." t
          unset command
      done
  }
#+END_SRC

#+NAME: main
#+BEGIN_SRC bash :eval no :exports code :tangle pkm.sh :tangle-mode (identity #o0755)
  ## Checking user parameters
  for arg in "$@"
  do
      case "$arg" in
          --updatePkgFromLocal)
              updatePkgFromLocal
              [ $? -gt 0 ] && quitPkm 1 "Error happen, check your installation."
              quitPkm 0
              ;;
          --updatePkm)
              updatePkm
              [ $? -gt 0 ] && quitPkm 1 "Error happen, check your installation."
              quitPkm 0
              ;;
          --autoBuildTmpToolChain)
              singleton ## Ensure only one instance runs.
              [ $? -gt 0 ] && quitPkm 1 "Singleton check failed."
              log "NULL|INFO|Starting PKM" t
              readConfig
              startLog
              startupCheck
              runAutoBuildTmpToolChain
              [ $? -gt 0 ] && quitPkm 1 "AutoBuildTmpToolChain return error."
              quitPkm 0 "AutoBuildTmpToolChain succesful."
              ;;

      esac
  done




  singleton ## Ensure only one instance runs.
  [ $? -gt 0 ] && quitPkm 1 "Singleton check failed."
  log "NULL|INFO|Starting PKM" t
  readConfig
  startLog
  startupCheck
  prompt
#+END_SRC

** enterLfs.sh
   This script is used to enter the chroot environment after the tool chain is done building.
#+BEGIN_SRC  bash :eval no :exports code :tangle enterLfs.sh :tangle-mode (identity #o0755)
  #!/bin/bash
  LFS=/mnt/lfs
  sudo chroot "$LFS" /tools/bin/env -i \
      HOME=/root                  \
      TERM="$TERM"                \
      PS1='(lfs chroot) \u:\w\$ ' \
      PATH=/bin:/usr/bin:/sbin:/usr/sbin:/tools/bin \
      /tools/bin/bash --login +h
#+END_SRC

** resetLfs.sh
#+BEGIN_SRC  bash :eval no :exports no :tangle resetLfs.sh :tangle-mode (identity #o0755)
#!/bin/bash
sudo umount -v /mnt/lfs/{boot,home}
sudo rmdir -v /mnt/lfs/{boot,home}
sudo rm -ir /mnt/lfs/tools
sudo umount /mnt/lfs
sudo userdel lfs
sudo groupdel lfs
sudo rm -fr /home/lfs
#+END_SRC
